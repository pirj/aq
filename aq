#!/usr/bin/env bash

# aq - QEMU wrapper to run Alpine Linux VMs on MacOS
# Usage: aq [new|start|stop|console|exec|scp|rm|ls] [args...]

[ -z "$DEBUG" ] || set -x
set -eu
set -o pipefail
set -fC

aq_help() {
  cat <<HELP
    aq new [-p host-port:vm-port ...] [vm-name]
    aq start vm-name
    aq stop vm-name
    aq console vm-name
    cat script.sh | aq exec vm-name
    aq exec vm-name nginx status
    aq exec vm-name < script.sh
    aq exec vm-name <<SH
      apk add nginx
      rc-service nginx start
    SH
    aq scp [-r] [-p] file1 file2... vm-name:/path
    aq scp [-r] [-p] vm-name:/file host-path
    aq rm vm-name
    aq ls
    aq --version
HELP
}

aq_version() {
  stderr aq $VERSION \"Repellent\" - QEMU wrapper to run Alpine Linux VMs on MacOS
}

random_vm_name() {
  # Approximately 200K words, 2^32 random names
  shuf -n 2 /usr/share/dict/words | tr '\n' '-'| sed 's/-$//'
}

VERSION=1.4

BASE_DIR=~/.local/share/aq
LATEST_ALPINE_VERSION=3.22.1
LATEST_ALPINE_MAJOR_MINOR=3.22
LATEST_ALPINE_ISO=alpine-virt-$LATEST_ALPINE_VERSION-aarch64.iso

LATEST_ALPINE_BASE=alpine-base-$LATEST_ALPINE_VERSION-aarch64.raw

download_alpine_iso() {
  mkdir -p $BASE_DIR
  (
    cd $BASE_DIR
    if [ ! -f $LATEST_ALPINE_ISO ]; then
      wget https://dl-cdn.alpinelinux.org/alpine/v$LATEST_ALPINE_MAJOR_MINOR/releases/aarch64/$LATEST_ALPINE_ISO
      wget https://dl-cdn.alpinelinux.org/alpine/v$LATEST_ALPINE_MAJOR_MINOR/releases/aarch64/$LATEST_ALPINE_ISO.asc
      wget -qO- https://alpinelinux.org/keys/ncopa.asc | gpg --import
      if ! gpg --verify $LATEST_ALPINE_ISO_ASC $LATEST_ALPINE_ISO; then
        echo "ERROR: Downloaded Apline ISO GPG signature verification failed!"
        rm -f $LATEST_ALPINE_ISO $LATEST_ALPINE_ISO_ASC
        exit 1
      fi
    fi
  )
}

# Waits for certain input, can type, etc
wait_for() {
  SCRIPT=$1
  socat UNIX:command.sock PTY,link=command.pty &
  SOCAT_PID=$!

  tio \
    --mute \
    --script "$SCRIPT" \
    --script-run once \
    command.pty \
    --exec 'echo ""'

  kill $SOCAT_PID
}

ensure_base_image() {
  [ -f $BASE_DIR/$LATEST_ALPINE_BASE ] || bootstrap_base_image
}

bootstrap_base_image() {
  download_alpine_iso
  (
    cd $BASE_DIR

    # Start from scratch
    rm -f wip-$LATEST_ALPINE_BASE
    rm -f uefi-vars.json

    qemu-img create -f raw wip-$LATEST_ALPINE_BASE 500M 1>/dev/null

    qemu-system-aarch64 \
      -machine virt,highmem=on -accel hvf -cpu host -m 1G \
      -drive file=$(brew --prefix qemu)/share/qemu/edk2-aarch64-code.fd,format=raw,if=pflash,readonly=on,unit=0 \
      -device uefi-vars-sysbus,jsonfile=$BASE_DIR/uefi-vars.json \
      -drive if=virtio,file=$BASE_DIR/wip-$LATEST_ALPINE_BASE,format=raw,cache=none \
      -boot order=cd -cdrom $BASE_DIR/$LATEST_ALPINE_ISO \
      -nic user,model=virtio-net-pci \
      -rtc base=utc,clock=host \
      -serial unix:$BASE_DIR/command.sock,server=on,wait=off,nodelay=on \
      -mon chardev=mon0,mode=readline -chardev socket,id=mon0,path=$BASE_DIR/control.sock,server=on,wait=off \
      -daemonize -pidfile $BASE_DIR/process.pid \
      -name wip-base-$LATEST_ALPINE_VERSION \
      -nographic \
      -parallel none \
      -monitor none

    # To debug, run:
    #   nc -U command.sock
    # or:
    #   socat STDIO UNIX:command.sock

    echo Booting up the base VM

    wait_for 'write("\n"); expect("localhost login: "); write("root\n")'

    echo  ..done

    echo Bootstrapping:

    cat <<BOOTSTRAP | socat STDIO UNIX:command.sock
cat <<SETUP-CONF > setup.conf
KEYMAPOPTS=none

# Set hostname to 'alpine'
HOSTNAMEOPTS=alpine

# Set device manager to mdev
DEVDOPTS=mdev

# Contents of /etc/network/interfaces
INTERFACESOPTS="auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
hostname alpine-test
"

# Search domain of example.com, Google public nameserver
# DNSOPTS="-d example.com 8.8.8.8"

# Set timezone to UTC
TIMEZONEOPTS="UTC"

# set http/ftp proxy
PROXYOPTS=none

# Add first mirror (CDN)
APKREPOSOPTS="-1"

# Create admin user
USEROPTS="-g floppy nouser"
ROOTSSHKEY="$(ls $HOME/.ssh | grep '\.pub$' | head -1 | xargs -I_ cat $HOME/.ssh/_)"

# Install Openssh
SSHDOPTS=openssh

# Use NTP
NTPOPTS="busybox"

# Use /dev/vda as a sys disk
DISKOPTS="-m sys /dev/vda"
SETUP-CONF
BOOTSTRAP

    # Install mkfs.ext4 (can be done without the network)
    echo "apk add e2fsprogs" | socat STDIO UNIX:command.sock

    echo "echo y | ROOTFS=ext4 setup-alpine -e -f setup.conf" | socat STDIO UNIX:command.sock

    wait_for 'expect("Installation is complete. Please reboot.")'

    cat <<SH  | socat STDIO UNIX:command.sock
mount /dev/vda3 /mnt
rm /mnt/root/setup.conf
umount /mnt
SH

    echo poweroff | socat STDIO UNIX:command.sock

    # FIXME: does it power off immediately?

    echo quit | nc -U control.sock

    # FIXME: does it exit immediately? wait for command.sock to disappear?

    # OS installed, vars written. Time to set in stone.
    chmod -w uefi-vars.json
    mv $BASE_DIR/{wip-,}$LATEST_ALPINE_BASE
    chmod -w $BASE_DIR/$LATEST_ALPINE_BASE
  )
}

stderr() {
  echo "$@" >&2
}

aq_new() {
  forwards=()
  while [ $# -gt 1 ]; do
    name=$1
    fwd=$2
    if [ "$name" = "-p" ]; then
      forwards+=($fwd); shift; shift
    fi
  done
  if [ $# -gt 0 ]; then
    VM_NAME=$1
  else
    VM_NAME=$(random_vm_name)
  fi
  ensure_base_image
  (
    cd $BASE_DIR
    mkdir $VM_NAME
    cd $VM_NAME
    touch hostfwd.conf
    if [ ${#forwards[@]} -gt 0 ]; then
      for forward in "${forwards[@]}"; do
        echo $forward >> hostfwd.conf
      done
    fi
    qemu-img create -b $BASE_DIR/$LATEST_ALPINE_BASE -F raw -f qcow2 storage.qcow2 2G 1>/dev/null

    cp ../uefi-vars.json .
    chmod +w uefi-vars.json

    touch .needs_first_boot_setup
  )
  stderr Created:
  echo $VM_NAME
}

# Supports 2222:22, or just 22, returns formatted hostfwd=tcp::2222-:22
hostfwd_directive() {
  HOST_PORT=$(echo $1 | cut -d: -f1)
  GUEST_PORT=$(echo $1 | cut -d: -f2)
  echo hostfwd=::$HOST_PORT-:$GUEST_PORT
}

# Generate a random high port number for temporary SSH forwarding
random_port() {
  shuf -i 49152-65535 -n 1
}

# Get or generate a persistent SSH port for a VM
get_persistent_ssh_port() {
  VM_NAME=$1
  SSH_PORT_FILE="$BASE_DIR/$VM_NAME/ssh-port.conf"

  if [ -f "$SSH_PORT_FILE" ]; then
    cat "$SSH_PORT_FILE"
  else
    # Generate a new port and store it
    NEW_PORT=$(random_port)
    echo "$NEW_PORT" > "$SSH_PORT_FILE"
    echo "$NEW_PORT"
  fi
}

# Add dynamic SSH port forwarding via QEMU monitor
add_ssh_forward() {
  VM_NAME=$1
  HOST_PORT=$2
  echo "hostfwd_add tcp::${HOST_PORT}-:22" | nc -U $BASE_DIR/$VM_NAME/control.sock
}

# Get SSH connection details for a VM
get_vm_ssh_details() {
  VM_NAME=$1
  SSH_PORT=$(get_persistent_ssh_port "$VM_NAME")
  echo "$SSH_PORT"
}

# Execute SSH command on VM with common options
vm_ssh() {
  VM_NAME=$1
  shift
  SSH_PORT=$(get_vm_ssh_details "$VM_NAME")
  ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p "$SSH_PORT" root@localhost "$@"
}

# Execute SCP command with VM using common options
vm_scp() {
  local vm_name="$1"
  shift
  local ssh_port=$(get_vm_ssh_details "$vm_name")
  scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -P "$ssh_port" "$@"
}

hostfwd() {
  VM_NAME=$1
  (
    cd $BASE_DIR/$VM_NAME
    directives=()
    for forward in $(cat hostfwd.conf); do
      directives+=($(hostfwd_directive $forward))
    done
    IFS=,
    if [ ${#directives[@]} -gt 0 ]; then
      echo "${directives[*]}"
    else
      echo ""
    fi
  )
}

vm_exists() {
  VM_NAME=$1
  [ -d "$BASE_DIR/$VM_NAME" ]
}

is_vm_running() {
  VM_NAME=$1
  [ -f "$BASE_DIR/$VM_NAME/process.pid" ] && kill -0 "$(cat "$BASE_DIR/$VM_NAME/process.pid" 2>/dev/null)" 2>/dev/null
}

first_boot_setup() {
  VM_NAME=$1
  (
    cd $BASE_DIR/$VM_NAME
    cat <<FIRST | socat STDIO UNIX:command.sock
hostname $VM_NAME
echo $VM_NAME > /etc/hostname
apk add partx sfdisk e2fsprogs-extra
echo ",+" | sfdisk --no-reread -N 3 /dev/vda --force
partx --update --nr 3 /dev/vda
resize2fs /dev/vda3
FIRST
  )
}

aq_start() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq start <vm-name>`.' && exit 1
  ! vm_exists "$VM_NAME" && stderr "Error: VM '$VM_NAME' does not exist." && exit 1

  # Check if VM is already running
  if is_vm_running "$VM_NAME"; then
    stderr "Error: VM '$VM_NAME' is already running."
    exit 1
  fi

  HOST_FORWARDS="$(hostfwd $VM_NAME)"

  qemu-system-aarch64 \
    -machine virt,highmem=on -accel hvf -cpu host -m 1G \
    -drive file=$(brew --prefix qemu)/share/qemu/edk2-aarch64-code.fd,format=raw,if=pflash,readonly=on,unit=0 \
    -device uefi-vars-sysbus,jsonfile=$BASE_DIR/$VM_NAME/uefi-vars.json \
    -drive if=virtio,file=$BASE_DIR/$VM_NAME/storage.qcow2 \
    -boot order=d \
    -nic user,model=virtio-net-pci,$HOST_FORWARDS \
    -rtc base=utc,clock=host \
    -serial unix:$BASE_DIR/$VM_NAME/command.sock,server=on,wait=off,nodelay=on \
    -mon chardev=mon0,mode=readline -chardev socket,id=mon0,path=$BASE_DIR/$VM_NAME/control.sock,server=on,wait=off \
    -daemonize -pidfile $BASE_DIR/$VM_NAME/process.pid \
    -name $VM_NAME \
    -nographic \
    -parallel none \
    -monitor none

  # Check if first boot setup is needed
  FIRST_BOOT_MARKER="$BASE_DIR/$VM_NAME/.needs_first_boot_setup"
  if [ -f "$FIRST_BOOT_MARKER" ]; then
    stderr "First boot detected, performing automated setup..."
    (
      cd $BASE_DIR/$VM_NAME
      wait_for 'expect("login: "); write("root\n")'
    )
    first_boot_setup "$VM_NAME"
    rm "$FIRST_BOOT_MARKER"
  else
    (
      cd $BASE_DIR/$VM_NAME
      wait_for 'expect("login: ")'
    )
  fi

  # Set up persistent SSH forwarding
  SSH_PORT=$(get_persistent_ssh_port "$VM_NAME")
  add_ssh_forward "$VM_NAME" "$SSH_PORT"

  stderr Started $VM_NAME
}

aq_stop() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq stop <vm-name>`.' && exit 1
  ! vm_exists "$VM_NAME" && stderr "Error: VM '$VM_NAME' does not exist." && exit 1

  # Clean up SSH port allocation file
  rm -f "$BASE_DIR/$VM_NAME/ssh-port.conf"

  # Only attempt to quit QEMU if VM is actually running
  if is_vm_running "$VM_NAME"; then
    echo quit | nc -U $BASE_DIR/$VM_NAME/control.sock 1>/dev/null
  fi
}

aq_console() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq console <vm-name>`.' && exit 1
  ! vm_exists "$VM_NAME" && stderr "Error: VM '$VM_NAME' does not exist." && exit 1

  vm_ssh "$VM_NAME"
}

aq_exec() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq exec <vm-name>`.' && exit 1
  ! vm_exists "$VM_NAME" && stderr "Error: VM '$VM_NAME' does not exist." && exit 1
  shift

  if [ -t 0 ] && [ $# -gt 0 ]; then # No stdin, have command-line arguments - execute them as a command
    vm_ssh "$VM_NAME" "$@"
  elif [ ! -t 0 ]; then # Have stdin - execute it as a script
    vm_ssh "$VM_NAME" 'sh -s'
  else
    stderr 'Error: No command or stdin provided. Usage: `aq exec <vm-name> [command]` or pipe input.'
    exit 1
  fi
}

aq_scp() {
  [ $# -lt 2 ] && stderr 'Error: At least source and destination required. Usage: `aq scp [-r] [-p] source... destination`.' && exit 1

  local scp_opts=("-B")
  local sources=()
  local destination=""
  local vm_name=""
  local is_vm_to_host=false

  # Parse options (-r, -p, etc.)
  while [[ $# -gt 0 && $1 == -* ]]; do
    scp_opts+=("$1")
    shift
  done

  [ $# -lt 2 ] && stderr 'Error: At least source and destination required after options.' && exit 1

  # Last argument is destination
  destination="${@: -1}"
  # All but last are sources
  sources=("${@:1:$(($#-1))}")

  # Determine direction and extract VM name
  if [[ "$destination" == *:* ]]; then
    # Host to VM
    vm_name="${destination%%:*}"
    [ -z "$vm_name" ] && stderr 'Error: VM name required in destination.' && exit 1

    # Validate all sources are on host (no colons)
    for source in "${sources[@]}"; do
      if [[ "$source" == *:* ]]; then
        stderr 'Error: Cannot mix VM and host sources when copying to VM.' && exit 1
      fi
    done
  else
    # VM to host
    is_vm_to_host=true

    # First source must contain VM name
    first_source="${sources[0]}"
    if [[ "$first_source" != *:* ]]; then
      stderr 'Error: First source must specify VM name (vm-name:/path) when destination is on host.' && exit 1
    fi

    vm_name="${first_source%%:*}"
    [ -z "$vm_name" ] && stderr 'Error: VM name required in first source.' && exit 1

    # Validate remaining sources
    for source in "${sources[@]:1}"; do
      if [[ "$source" == *:* ]]; then
        source_vm="${source%%:*}"
        if [ -n "$source_vm" ] && [ "$source_vm" != "$vm_name" ]; then
          stderr "Error: Inconsistent VM names: '$vm_name' vs '$source_vm'." && exit 1
        fi
      else
        stderr 'Error: All sources must be VM paths (vm-name:/path or :/path) when destination is on host.' && exit 1
      fi
    done

    # Normalize sources - prepend vm_name to those starting with ":"
    local normalized_sources=()
    for source in "${sources[@]}"; do
      if [[ "$source" == :* ]]; then
        normalized_sources+=("${vm_name}${source}")
      else
        normalized_sources+=("$source")
      fi
    done
    sources=("${normalized_sources[@]}")
  fi

  # Check if VM exists
  ! vm_exists "$vm_name" && stderr "Error: VM '$vm_name' does not exist." && exit 1

  # Convert VM paths to use localhost with SSH port
  local scp_sources=()
  local scp_destination="$destination"

  if [ "$is_vm_to_host" = true ]; then
    # Convert VM sources to SSH format
    for source in "${sources[@]}"; do
      if [[ "$source" == *:* ]]; then
        vm_path="${source#*:}"
        scp_sources+=("root@localhost:${vm_path}")
      fi
    done
  else
    # Host to VM - convert destination
    vm_path="${destination#*:}"
    scp_destination="root@localhost:${vm_path}"
    scp_sources=("${sources[@]}")
  fi

  # Execute scp command using helper
  vm_scp "$vm_name" "${scp_opts[@]}" "${scp_sources[@]}" "$scp_destination"
}

aq_rm() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq rm <vm-name>`.' && exit 1
  ! vm_exists "$VM_NAME" && stderr "Error: VM '$VM_NAME' does not exist." && exit 1

  aq_stop $VM_NAME
  rm -rf $BASE_DIR/$VM_NAME
  stderr "Removed" $VM_NAME
}

aq_ls() {
  [ ! -d "$BASE_DIR" ] && return 0

  (
    cd "$BASE_DIR"
    for vm_dir in $(ls); do
      [ ! -d "$vm_dir" ] && continue
      vm_name=$(basename "$vm_dir")
      if is_vm_running "$vm_name"; then
        status="On"
      else
        status="Off"
      fi

      # Get SSH port if available
      ssh_port=""
      if [ -f "$vm_dir/ssh-port.conf" ]; then
        ssh_port=$(cat "$vm_dir/ssh-port.conf")
        ssh_port=":$ssh_port"
      fi

      printf "%-20s %-4s %s\n" "$vm_name" "$status" "$ssh_port"
    done
  )
}

[ $# -gt 0 ] && { COMMAND=$1; shift; } || COMMAND=""
case $COMMAND in
  new) aq_new $* ;;
  start) aq_start $* ;;
  stop) aq_stop $* ;;
  console) aq_console $* ;;
  exec) aq_exec $* ;;
  scp) aq_scp $* ;;
  rm) aq_rm $* ;;
  ls) aq_ls ;;
  "--version") aq_version ;;
  "" | "help" | "-h" | "--help") aq_help ;;
  *) stderr "Error: Unknown command $COMMAND."; exit 1 ;;
esac

exit 0
