#!/usr/bin/env bash

# aq - QEMU wrapper script
# Usage: aq [new|start|stop|console|exec|rm|ls] [args...]

[ -z "$DEBUG" ] || set -x
set -eu
set -o pipefail
set -fC

aq_help() {
  cat <<HELP
    aq new [-p host-port:vm-port ...] [vm-name]
    aq start vm-name
    aq stop vm-name
    aq console vm-name
    cat script.sh | aq exec vm-name
    aq rm vm-name
    aq ls
HELP
}

random_vm_name() {
  # Approximately 200K words, 2^32 random names
  shuf -n 2 /usr/share/dict/words | tr '\n' '-'| sed 's/-$//'
}

BASE_DIR=~/.local/share/aq
LATEST_ALPINE_VERSION=3.22.1
LATEST_ALPINE_MAJOR_MINOR=3.22
LATEST_ALPINE_ISO=alpine-virt-$LATEST_ALPINE_VERSION-aarch64.iso

LATEST_ALPINE_BASE=alpine-base-$LATEST_ALPINE_VERSION-aarch64.raw

download_alpine_iso() {
  mkdir -p $BASE_DIR
  (
    cd $BASE_DIR
    [ -f $LATEST_ALPINE_ISO ] || wget https://dl-cdn.alpinelinux.org/alpine/v$LATEST_ALPINE_MAJOR_MINOR/releases/aarch64/$LATEST_ALPINE_ISO
  )
}

# Waits for certain input, can type, etc
wait_for() {
  SCRIPT=$1
  socat UNIX:command.sock PTY,link=command.pty &
  SOCAT_PID=$!

  tio \
    --mute \
    --script "$SCRIPT" \
    --script-run once \
    command.pty \
    --exec 'echo ""'

  kill $SOCAT_PID
}

ensure_base_image() {
  [ -f $BASE_DIR/$LATEST_ALPINE_BASE ] || bootstrap_base_image
}

bootstrap_base_image() {
  download_alpine_iso
  (
    cd $BASE_DIR

    # Start from scratch
    rm -f wip-$LATEST_ALPINE_BASE
    rm -f uefi-vars.json

    qemu-img create -f raw wip-$LATEST_ALPINE_BASE 500M 1>/dev/null

    qemu-system-aarch64 \
      -machine virt,highmem=on -accel hvf -cpu host -m 1G \
      -drive file=$(brew --prefix qemu)/share/qemu/edk2-aarch64-code.fd,format=raw,if=pflash,readonly=on,unit=0 \
      -device uefi-vars-sysbus,jsonfile=$BASE_DIR/uefi-vars.json \
      -drive if=virtio,file=$BASE_DIR/wip-$LATEST_ALPINE_BASE,format=raw,cache=none \
      -boot order=cd -cdrom $BASE_DIR/$LATEST_ALPINE_ISO \
      -nic user,model=virtio-net-pci \
      -rtc base=utc,clock=host \
      -serial unix:$BASE_DIR/command.sock,server=on,wait=off,nodelay=on \
      -mon chardev=mon0,mode=readline -chardev socket,id=mon0,path=$BASE_DIR/control.sock,server=on,wait=off \
      -daemonize -pidfile $BASE_DIR/process.pid \
      -name wip-base-$LATEST_ALPINE_VERSION \
      -nographic \
      -parallel none \
      -monitor none

    # To debug, run:
    #   nc -U command.sock
    # or:
    #   socat STDIO UNIX:command.sock

    echo Booting up the base VM

    wait_for 'write("\n"); expect("localhost login: "); write("root\n")'

    echo  ..done

    echo Bootstrapping:

    cat <<BOOTSTRAP | socat STDIO UNIX:command.sock
cat <<SETUP-CONF > setup.conf
KEYMAPOPTS=none

# Set hostname to 'alpine'
HOSTNAMEOPTS=alpine

# Set device manager to mdev
DEVDOPTS=mdev

# Contents of /etc/network/interfaces
INTERFACESOPTS="auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
hostname alpine-test
"

# Search domain of example.com, Google public nameserver
# DNSOPTS="-d example.com 8.8.8.8"

# Set timezone to UTC
TIMEZONEOPTS="UTC"

# set http/ftp proxy
PROXYOPTS=none

# Add first mirror (CDN)
APKREPOSOPTS="-1"

# Create admin user
USEROPTS="-g floppy nouser"
ROOTSSHKEY="$(ls $HOME/.ssh | grep '\.pub$' | head -1 | xargs -I_ cat $HOME/.ssh/_)"

# Install Openssh
SSHDOPTS=openssh

# Use NTP
NTPOPTS="busybox"

# Use /dev/vda as a sys disk
DISKOPTS="-m sys /dev/vda"
SETUP-CONF
BOOTSTRAP

    # Install mkfs.ext4 (can be done without the network)
    echo "apk add e2fsprogs" | socat STDIO UNIX:command.sock

    echo "echo y | ROOTFS=ext4 setup-alpine -e -f setup.conf" | socat STDIO UNIX:command.sock

    wait_for 'expect("Installation is complete. Please reboot.")'

    echo "rm setup.conf" | socat STDIO UNIX:command.sock

    echo poweroff | socat STDIO UNIX:command.sock

    # FIXME: does it power off immediately?

    echo quit | nc -U control.sock

    # FIXME: does it exit immediately? wait for command.sock to disappear?

    # OS installed, vars written. Time to set in stone.
    chmod -w uefi-vars.json
    mv $BASE_DIR/{wip-,}$LATEST_ALPINE_BASE
    chmod -w $BASE_DIR/$LATEST_ALPINE_BASE
  )
}

stderr() {
  echo "$@" >&2
}

aq_new() {
  forwards=()
  while [ $# -gt 1 ]; do
    name=$1
    fwd=$2
    if [ "$name" = "-p" ]; then
      forwards+=($fwd); shift; shift
    fi
  done
  if [ $# -gt 0 ]; then
    VM_NAME=$1
  else
    VM_NAME=$(random_vm_name)
  fi
  ensure_base_image
  (
    cd $BASE_DIR
    mkdir $VM_NAME
    cd $VM_NAME
    touch hostfwd.conf
    if [ ${#forwards[@]} -gt 0 ]; then
      for forward in "${forwards[@]}"; do
        echo $forward >> hostfwd.conf
      done
    fi
    qemu-img create -b $BASE_DIR/$LATEST_ALPINE_BASE -F raw -f qcow2 storage.qcow2 2G 1>/dev/null

    cp ../uefi-vars.json .
    chmod +w uefi-vars.json
  )
  stderr Created:
  echo $VM_NAME
}

# Supports 2222:22, or just 22, returns formatted hostfwd=tcp::2222-:22
hostfwd_directive() {
  HOST_PORT=$(echo $1 | cut -d: -f1)
  GUEST_PORT=$(echo $1 | cut -d: -f2)
  echo hostfwd=::$HOST_PORT-:$GUEST_PORT
}

# Generate a random high port number for temporary SSH forwarding
random_port() {
  shuf -i 49152-65535 -n 1
}

# Add dynamic SSH port forwarding via QEMU monitor
add_ssh_forward() {
  VM_NAME=$1
  HOST_PORT=$2
  echo "hostfwd_add tcp::${HOST_PORT}-:22" | nc -U $BASE_DIR/$VM_NAME/control.sock
}

# Remove dynamic SSH port forwarding via QEMU monitor
remove_ssh_forward() {
  VM_NAME=$1
  HOST_PORT=$2
  echo "hostfwd_remove tcp::${HOST_PORT}-:22" | nc -U $BASE_DIR/$VM_NAME/control.sock
}

hostfwd() {
  VM_NAME=$1
  (
    cd $BASE_DIR/$VM_NAME
    directives=()
    for forward in $(cat hostfwd.conf); do
      directives+=($(hostfwd_directive $forward))
    done
    IFS=,
    if [ ${#directives[@]} -gt 0 ]; then
      echo "${directives[*]}"
    else
      echo ""
    fi
  )
}

aq_start() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq start <vm-name>`.' && exit 1

  HOST_FORWARDS="$(hostfwd $VM_NAME)"

  qemu-system-aarch64 \
    -machine virt,highmem=on -accel hvf -cpu host -m 1G \
    -drive file=$(brew --prefix qemu)/share/qemu/edk2-aarch64-code.fd,format=raw,if=pflash,readonly=on,unit=0 \
    -device uefi-vars-sysbus,jsonfile=$BASE_DIR/$VM_NAME/uefi-vars.json \
    -drive if=virtio,file=$BASE_DIR/$VM_NAME/storage.qcow2 \
    -boot order=d \
    -nic user,model=virtio-net-pci,$HOST_FORWARDS \
    -rtc base=utc,clock=host \
    -serial unix:$BASE_DIR/$VM_NAME/command.sock,server=on,wait=off,nodelay=on \
    -mon chardev=mon0,mode=readline -chardev socket,id=mon0,path=$BASE_DIR/$VM_NAME/control.sock,server=on,wait=off \
    -daemonize -pidfile $BASE_DIR/$VM_NAME/process.pid \
    -name $VM_NAME \
    -nographic \
    -parallel none \
    -monitor none

  stderr Started $VM_NAME
}

aq_stop() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq stop <vm-name>`.' && exit 1
  echo quit | nc -U $BASE_DIR/$VM_NAME/control.sock 1>/dev/null
}

aq_console() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq console <vm-name>`.' && exit 1

  SSH_PORT=$(random_port)
  add_ssh_forward $VM_NAME $SSH_PORT # Add temporary SSH port forwarding
  ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p $SSH_PORT root@localhost
  remove_ssh_forward $VM_NAME $SSH_PORT
}

aq_exec() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq exec <vm-name> <shell-script>`.' && exit 1
  nc -U app.sock
  stderr "Not implemented yet"
}

aq_rm() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq rm <vm-name>`.' && exit 1
  stderr "Not implemented yet"
}

aq_ls() {
  stderr "Not implemented yet"
}

COMMAND=$1
shift
case $COMMAND in
  new) aq_new $* ;;
  start) aq_start $* ;;
  stop) aq_stop $* ;;
  console) aq_console $* ;;
  exec) aq_exec $* ;;
  rm) aq_rm $* ;;
  ls) aq_ls ;;
  "" | "help" | "-h" | "--help") aq_help ;;
  *) stderr "Error: Unknown command $COMMAND."; exit 1 ;;
esac

exit 0
