#!/usr/bin/env sh

# aq - QEMU wrapper script
# Usage: aq [new|start|stop|console|exec|rm|ls] [args...]

# set -e
# set -o pipefail Bashism

aq_help() {
  cat <<HELP
    aq new [-p host-port:vm-port ...] [vm-name]
    aq start vm-name
    aq stop vm-name
    aq console vm-name
    cat script.sh | aq exec vm-name
    aq rm vm-name
    aq ls
HELP
}

random_vm_name() {
  # Approximately 200K words, 2^32 random names
  shuf -n 2 /usr/share/dict/words | tr '\n' '-'| sed 's/-$//'
}

BASE_DIR=~/.local/share/aq
LATEST_ALPINE_VERSION=3.22.1
LATEST_ALPINE_ISO=alpine-virt-$LATEST_ALPINE_VERSION-aarch64.iso
LATEST_ALPINE_BASE=alpine-base-$LATEST_ALPINE_VERSION-aarch64.qcow2

download_alpine_iso() {
  mkdir -p $BASE_DIR
  (
    cd $BASE_DIR
    [ -f $LATEST_ALPINE_ISO ] || wget https://dl-cdn.alpinelinux.org/alpine/v$LATEST_ALPINE_MAJOR_MINOR/releases/aarch64/$LATEST_ALPINE_ISO
  )
}

# Waits for certain input, can type, etc
wait_for() {
  SCRIPT=$1
  socat UNIX:command.sock PTY,link=command.pty &
  SOCAT_PID=$!

  tio \
    --mute \
    --script "$1" \
    --script-run once \
    command.pty \
    --exec 'echo ""'

  kill $SOCAT_PID
}

ensure_base_image() {
  [ -f $BASE_DIR/$LATEST_ALPINE_BASE ] || bootstrap_base_image
}

bootstrap_base_image() {
  download_alpine_iso
  (
    cd $BASE_DIR

    # Start from scratch
    rm -f wip-$LATEST_ALPINE_BASE

    qemu-img create -f qcow2 wip-$LATEST_ALPINE_BASE 500M 1>/dev/null

    cp $(brew --prefix qemu)/share/qemu/edk2-aarch64-code.fd uefi_vars.fd

    qemu-system-aarch64 \
      -machine virt,highmem=on -accel hvf -cpu host -m 1G \
      -drive file=$(brew --prefix qemu)/share/qemu/edk2-aarch64-code.fd,format=raw,if=pflash,readonly=on,unit=0 \
      -drive file=uefi_vars.fd,format=raw,if=pflash,unit=1 \
      -drive if=virtio,file=$BASE_DIR/wip-$LATEST_ALPINE_BASE,cache=none \
      -boot order=cd -cdrom $BASE_DIR/$LATEST_ALPINE_ISO \
      -nic user,model=virtio-net-pci \
      -rtc base=utc,clock=host \
      -serial unix:$BASE_DIR/command.sock,server=on,wait=off,nodelay=on \
      -mon chardev=mon0,mode=readline -chardev socket,id=mon0,path=$BASE_DIR/control.sock,server=on,wait=off \
      -daemonize -pidfile $BASE_DIR/process.pid \
      -name wip-base-$LATEST_ALPINE_VERSION \
      -nographic \
      -parallel none \
      -monitor none

    # To debug, run:
    #   nc -U command.sock
    # or:
    #   socat STDIO UNIX:command.sock

    echo Booting up the base VM

    wait_for 'write("\n"); expect("localhost login: "); write("root\n")'

    echo  ..done

    echo Bootstrapping:

    cat <<BOOTSTRAP | socat STDIO UNIX:command.sock
cat <<SETUP-CONF > setup.conf
KEYMAPOPTS=none

# Set hostname to 'alpine'
HOSTNAMEOPTS=alpine

# Set device manager to mdev
DEVDOPTS=mdev

# Contents of /etc/network/interfaces
INTERFACESOPTS="auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
hostname alpine-test
"

# Search domain of example.com, Google public nameserver
# DNSOPTS="-d example.com 8.8.8.8"

# Set timezone to UTC
TIMEZONEOPTS="UTC"

# set http/ftp proxy
PROXYOPTS=none

# Add first mirror (CDN)
APKREPOSOPTS="-1"

# Create admin user
USEROPTS="-g floppy nouser"
ROOTSSHKEY="$(cat ~/.ssh/*.pub | head -1)"

# Install Openssh
SSHDOPTS=openssh

# Use NTP
NTPOPTS="busybox"

# Use /dev/vda as a sys disk
DISKOPTS="-m sys /dev/vda"
SETUP-CONF
BOOTSTRAP

    echo "echo y | setup-alpine -e -f setup.conf" | socat STDIO UNIX:command.sock

    wait_for 'expect("Installation is complete. Please reboot.")'

    echo poweroff | socat STDIO UNIX:command.sock

    echo quit | nc -U control.sock

    # FIXME: does it exit immediately? wait for command.sock to disappear?

    # OS installed, vars written. Time to set in stone.
    chmod -w uefi_vars.fd
    mv $BASE_DIR/{wip-,}$LATEST_ALPINE_BASE
    chmod -w $BASE_DIR/$LATEST_ALPINE_BASE
  )
}

stderr() {
  echo "$@" >&2
}

aq_new() {
  forwards=()
  while [ "$1" = "-p" ]; do
    forwards+=($2); shift; shift
  done
  VM_NAME=$1
  [ -z "$VM_NAME" ] && VM_NAME=$(random_vm_name)
  ensure_base_image
  (
    cd $BASE_DIR
    mkdir $VM_NAME
    cd $VM_NAME
    for forward in "${forwards[@]}"; do
      echo $forward >> hostfwd
    done
    qemu-img create -b $BASE_DIR/$LATEST_ALPINE_BASE -F qcow2 -f qcow2 storage.qcow2 2G 1>/dev/null

    ln -s ../uefi_vars.fd uefi_vars.fd
  )
  stderr Created:
  echo $VM_NAME
}

# Support 2222:22, or just 22, returns formatted hostfwd=tcp::2222-:22
# TODO: support protocol: tcp/udp
#       support hostaddr
#       support guestaddr
hostfwd_directive() {
  HOST_PORT=$(echo $1 | cut -d: -f1)
  GUEST_PORT=$(echo $1 | cut -d: -f2)
  echo hostfwd=::$HOST_PORT-:$GUEST_PORT
}

hostfwd() {
  VM_NAME=$1
  (
    cd $BASE_DIR/$VM_NAME
    directives=()
    for forward in $(cat hostfwd); do
      directives+=($(hostfwd_directive $forward))
    done
    IFS=,
    echo "${directives[*]}"
  )
}

aq_start() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq start <vm-name>`.' && exit 1

  HOST_FORWARDS=$(hostfwd $VM_NAME)

  rm -f $BASE_DIR/$VM_NAME/console.pty # In case of a ungraceful exit
  qemu-system-aarch64 \
    -machine virt,highmem=on -accel hvf -cpu host -m 1G \
    -drive file=$(brew --prefix qemu)/share/qemu/edk2-aarch64-code.fd,format=raw,if=pflash,readonly=on,unit=0 \
    -drive file=$BASE_DIR/$VM_NAME/uefi_vars.fd,format=raw,if=pflash,unit=1 \
    -drive if=virtio,file=$BASE_DIR/$VM_NAME/storage.qcow2 \
    -boot order=d \
    -nic user,model=virtio-net-pci,$HOST_FORWARDS \
    -rtc base=utc,clock=host \
    -serial unix:$BASE_DIR/$VM_NAME/command.sock,server=on,wait=off,nodelay=on \
    -serial pty:$BASE_DIR/$VM_NAME/console.pty \
    -mon chardev=mon0,mode=readline -chardev socket,id=mon0,path=$BASE_DIR/$VM_NAME/control.sock,server=on,wait=off \
    -daemonize -pidfile $BASE_DIR/$VM_NAME/process.pid \
    -name $VM_NAME \
    -nographic \
    -parallel none \
    -monitor none

  stderr Started $VM_NAME
}

aq_stop() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq stop <vm-name>`.' && exit 1
  echo quit | nc -U $BASE_DIR/$VM_NAME/control.sock 1>/dev/null
}

aq_console() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq console <vm-name>`.' && exit 1
  tio $BASE_DIR/$VM_NAME/console.pty
}

aq_exec() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq exec <vm-name> <shell-script>`.' && exit 1
  nc -U app.sock
  stderr "Not implemented yet"
}

aq_rm() {
  VM_NAME=$1
  [ -z "$VM_NAME" ] && stderr 'Error: VM name required: `aq rm <vm-name>`.' && exit 1
  stderr "Not implemented yet"
}

aq_ls() {
  stderr "Not implemented yet"
}

COMMAND=$1
shift
case $COMMAND in
  new) aq_new $* ;;
  start) aq_start $* ;;
  stop) aq_stop $* ;;
  console) aq_console $* ;;
  exec) aq_exec $* ;;
  rm) aq_rm $* ;;
  ls) aq_ls ;;
  "" | "help" | "-h" | "--help") aq_help ;;
  *) stderr "Error: Unknown command $COMMAND."; exit 1 ;;
esac

exit 0
